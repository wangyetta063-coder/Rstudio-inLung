install.packages("devtools")
install.packages("Matrix")
install.packages("Matrix.utils")
# 1. 先装 remotes（如果已装会自动跳过/更新）
install.packages("remotes")
# 2. 加载 remotes
library(remotes)
# 3. 从 GitHub 安装 monocle3（不要加 ref 参数）
remotes::install_github("cole-trapnell-lab/monocle3")

BiocManager::install(c("BiocGenerics", "DelayedArray", "DelayedMatrixStats",
                       "limma", "S4Vectors", "SingleCellExperiment"))
install.packages("igraph", type = "binary")

install.packages("devtools")
install.packages("Matrix")
install.packages("devtools")
library(devtools)
install_github("cole-trapnell-lab/monocle3", ref = "1.4.3")
if (!requireNamespace("BiocManager", quietly = TRUE)) {
   install.packages("BiocManager")
}
BiocManager::install(version = "3.21")



#开始
library(monocle3)
library(SeuratWrappers)
library(Seurat)
library(ggplot2)
library(tidyverse)
library(data.table)   # 加速读取大型文件
library(Matrix)
sessionInfo()#真实桌面路径
getwd()

####开始运行
# script to perform trajectory analysis
# https://www.nature.com/articles/s41467-019-10291-0
# setwd("C:/Users/Administrator/Desktop")


set.seed(1234)
# read in data
# gene metadata
markers <- read.delim("ABC_Marker.txt",header = TRUE,check.names = FALSE) # gene metadata
metadata <- read.delim("ABC_Meta.txt",header = TRUE,check.names = FALSE) # cell metadata
expr <- read.delim('ABC_umi_matrix_7551_cells.csv', header = TRUE, sep = ',') # expression matrix

#############################修改：
library(Seurat)
library(Matrix)
library(data.table)

## 1. 正确读取 cell × gene 矩阵（第一列废弃）
expr_df <- fread("ABC_umi_matrix_7551_cells.csv",
                 header = TRUE,
                 sep = ",",
                 data.table = FALSE,
                 check.names = FALSE)

## 2. 丢弃第一列（它不是细胞名，而是无意义的重复“0”列）
expr_df <- expr_df[, -1]

## 3. 当前是 cell × gene → 转置成 gene × cell
expr_mat <- t(as.matrix(expr_df))

## 4. 行名 = 基因名（来自原 CSV 的列名）
rownames(expr_mat) <- colnames(expr_df)

## 5. 使基因名唯一（你之前统计 7550 个重复）
rownames(expr_mat) <- make.unique(rownames(expr_mat))

## 6. 自动为细胞生成唯一名字
colnames(expr_mat) <- paste0("Cell_", seq_len(ncol(expr_mat)))

## 7. 转稀疏矩阵
expr_mat <- as(expr_mat, "dgCMatrix")

## 8. 创建 Seurat 对象（不会再报错）
seu.obj <- CreateSeuratObject(counts = expr_mat)

## 9. 计算线粒体比例（人类基因以 MT- 开头）
seu.obj[["mitopercent"]] <- PercentageFeatureSet(seu.obj, pattern = "^MT-")

## 10. 查看是否正常
head(seu.obj@meta.data)


############# 【5】创建全新的 Seurat 对象（这里报错！@！！！！！！！！！！！！！！！！）
seu.obj <- CreateSeuratObject(counts = expr_mat)

## 【6】计算线粒体比例（人类：MT-）
seu.obj[["mitopercent"]] <- PercentageFeatureSet(seu.obj, pattern = "^MT-")
#（以上都是对的）
##

# 这里有报错create seurat object ---------------
library(Seurat)
library(Matrix)
library(data.table)

## 1. 读取 cell×gene 数据
expr_df <- fread("ABC_umi_matrix_7551_cells.csv",
                 header = TRUE,
                 sep = ",",
                 data.table = FALSE,
                 check.names = FALSE)

## 2. 第一列就是 cell_id，必须保留
cell_ids <- expr_df[[1]]

## 3. 去掉第一列（保留 gene）
expr_df <- expr_df[, -1]

## 4. 转置成 gene×cell
expr_mat <- t(as.matrix(expr_df))

## 5. 行名 = 基因名（唯一化）
rownames(expr_mat) <- make.unique(colnames(expr_df))

## 6. 列名 = 原始 cell_id（真实细胞名）
colnames(expr_mat) <- cell_ids

## 7. 转稀疏矩阵
expr_mat <- as(expr_mat, "dgCMatrix")

## 8. 创建 Seurat 对象
seu.obj <- CreateSeuratObject(counts = expr_mat)


#############以上修改###￥######
metadata <- read.delim("ABC_Meta.txt", header = TRUE, check.names = FALSE)

# metadata 已经是 rownames = cell_id
rownames(metadata) <- metadata$cell_id

# 只保留与表达矩阵匹配的细胞
metadata_use <- metadata[colnames(seu.obj), , drop = FALSE]

# 正常添加
seu.obj <- AddMetaData(seu.obj, metadata_use)

# 计算线粒体比例
seu.obj[["mitopercent"]] <- PercentageFeatureSet(seu.obj, pattern = "^MT-")

## ----------------------------------------------------
## ▶️【QC 过滤】
seu.obj.filtered <- subset(seu.obj, subset =
                              nCount_RNA > 800 &
                              nFeature_RNA > 500 &
                              mitopercent < 10)

## 检查结果
head(seu.obj.filtered@meta.data)
#（以上是修改部分）全部正确#####￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥#￥

# subset my seurat object - B cells

Idents(seu.obj.filtered) <- seu.obj.filtered$redefined_cluster
b.seu <- subset(seu.obj.filtered, idents = "B-NK2")
b.seu
unique(b.seu@meta.data$redefined_cluster)
##以上正确
# pre-processing using seurat
# 1. Seurat preprocessing
b.seu <- NormalizeData(b.seu)
b.seu <- FindVariableFeatures(b.seu, selection.method = "vst", nfeatures = 2000)
b.seu <- ScaleData(b.seu)

# 2. PCA
b.seu <- RunPCA(b.seu, npcs = 30)

# 3. Neighbors + Clusters
b.seu <- FindNeighbors(b.seu, dims = 1:20)   # B细胞通常不需要用到1:30
b.seu <- FindClusters(b.seu, resolution = 0.9)

# 4. UMAP
b.seu <- RunUMAP(b.seu, dims = 1:20, n.neighbors = 50)

# 5. Plot
a1 <- DimPlot(b.seu, reduction = 'umap', group.by = 'redefined_cluster', label = TRUE) +
   ggtitle("B-cell subtype mapping (original labels)")

a2 <- DimPlot(b.seu, reduction = 'umap', group.by = 'seurat_clusters', label = TRUE) +
   ggtitle("B-cell reclustering")

a1 | a2


# MONOCLE3 WORKFLOW ---------------------
# monocle3 requires cell_data_set object
# convert seurat object to cell_data_set object for monocle3
library(monocle3)

# 1. 转换：Seurat → monocle3
cds <- as.cell_data_set(b.seu)

# 2. 修复 metadata（monocle3 强制要求 data.frame）
colData(cds) <- DataFrame(colData(cds))

# 3. 提供 gene_short_name（如果没有会报错）
fData(cds)$gene_short_name <- rownames(fData(cds))

# 检查
cds
head(colData(cds))
head(fData(cds))
#####修改￥￥￥￥￥￥￥￥￥￥￥￥￥
fread("ABC_umi_matrix_7551_cells.csv", nrows = 3)



# ...2. Cluster cells (using clustering info from seurat's UMAP)---------------------------
# let's use the clustering information have

# assign paritions
reacreate.partition <- c(rep(1,length(cds@colData@rownames)))
names(reacreate.partition) <- cds@colData@rownames
reacreate.partition <- as.factor(reacreate.partition)


cds@clusters$UMAP$partitions <- reacreate.partition

# Assign the cluster info 

list_cluster <- b.seu@active.ident
cds@clusters$UMAP$clusters <- list_cluster


# Assign UMAP coordinate - cell embeddings

cds@int_colData@listData$reducedDims$UMAP <- b.seu@reductions$umap@cell.embeddings



# plot

cluster.before.trajectory <- plot_cells(cds,
                                        color_cells_by = 'cluster',
                                        label_groups_by_cluster = FALSE,
                                        group_label_size = 5) +
   theme(legend.position = "right")

cluster.names <- plot_cells(cds,
                            color_cells_by = "redefined_cluster",
                            label_groups_by_cluster = FALSE,
                            group_label_size = 5) +
   scale_color_manual(values = c('red', 'blue', 'green', 'maroon', 'yellow', 'grey', 'cyan')) +
   theme(legend.position = "right")

cluster.before.trajectory | cluster.names



# ...3. Learn trajectory graph ------------------------
cds <- learn_graph(cds, use_partition = FALSE)

plot_cells(cds,
           color_cells_by = 'redefined_cluster',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE,
           group_label_size = 5)


# ...4. Order the cells in pseudotime -------------------

cds <- order_cells(cds, reduction_method = 'UMAP', root_cells = colnames(cds[,clusters(cds) == 5]))

plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE)

# cells ordered by monocle3 pseudotime

pseudotime(cds)
cds$monocle3_pseudotime <- pseudotime(cds)
data.pseudo <- as.data.frame(colData(cds))

ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(redefined_cluster, monocle3_pseudotime, median), fill = redefined_cluster)) +
   geom_boxplot()




# ...5. Finding genes that change as a function of pseudotime --------------------
deg_bcells <- graph_test(cds, neighbor_graph = 'principal_graph', cores = 4)

deg_bcells %>% 
   arrange(q_value) %>% 
   filter(status == 'OK') %>% 
   head()

FeaturePlot(b.seu, features = c('E2F2', 'STMN1', 'CD52'))


# visualizing pseudotime in seurat

b.seu$pseudotime <- pseudotime(cds)
Idents(b.seu) <- b.seu$redefined_cluster
FeaturePlot(b.seu, features = "pseudotime", label = T)





